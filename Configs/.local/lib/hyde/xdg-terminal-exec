#!/bin/sh
set -euf
OIFS="$IFS"
N='
'
SELF_NAME=${0##*/}
RSEP=$(printf '%b' '\036')
USEP=$(printf '%b' '\037')
error() {
	printf '%s\n' "$@" >&2
}
check_bool() {
	case "$1" in
	true | True | TRUE | yes | Yes | YES | 1) return 0 ;;
	false | False | FALSE | no | No | NO | 0) return 1 ;;
	*)
		error "Assuming '$1' means no"
		return 1
		;;
	esac
}
if check_bool "${DEBUG-0}"; then
	debug() {
		while IFS='' read -r debug_line; do
			printf 'D: %s\n' "$debug_line"
		done <<-EOF >&2
			$(printf '%s\n' "$@")
		EOF
	}
else
	debug() { :; }
fi
shcat() {
	while IFS='' read -r line; do
		printf '%s\n' "$line"
	done
}
usage() {
	shcat <<-EOF
		Usage:
		  $SELF_NAME [options] [--] [command [arguments ...]]
	EOF
}
help() {
	shcat <<-EOF
		$SELF_NAME - Shell-based default terminal launcher.

		Implementation of the proposed Default Terminal Specification.

		$(usage)

		Launches given command in default terminal, or launches default terminal.

		Options for modifying terminal behavior (if supported by terminals's
		entry):

		  --app-id=app-id set app-id (Wayland) or window class (X11)
		  --title=title    set tile of terminal.
		  --dir=workdir    set workdir of terminal.
		  --hold           instruct terminal to hold after command ends.

		Options for printing data instead of executing terminal:

		  --print-id
		   print selected Desktop Entry ID. Action is appended delimited
		   by ":".

		  --print-path
		   print path to selected Desktop Entry. Action is appended
		   delimited by ":".

		  --print-content
		   print content of selected Desktop Entry. Conflicts with --print-cmd.

		  --print-cmd[=printf_sequence]
		   print resulting command line, delimited by given printf sequence,
		   "\\n" by default. If sequence is "\\n", output is also terminated with
		   a newline.

		  --print-delimiter=printf_sequence
		   printf sequence to be used as the delimiter between multiple requested
		   print statements, "\\n" by default. If sequence is "\\n", output is
		   also terminated with a newline.

		Configuration:

		Preferred terminals are configured by listing their Desktop Entry IDs
		in config files named "[\${desktop}-]xdg-terminals.list" placed in XDG Config
		hierarchy. Where "\${desktop}" is a lowercased string that is matched
		(case-insensitively) against items of "\${XDG_CURRENT_DESKTOP}".

		See "man $SELF_NAME" for more details.
	EOF
}
make_paths() {
	IFS=':'
	for dir in ${XDG_CONFIG_HOME:-"$HOME/.config"}$IFS${XDG_CONFIG_DIRS:-/etc/xdg}; do
		for desktop in $LOWERCASE_XDG_CURRENT_DESKTOP; do
			CONFIGS=${CONFIGS:+$CONFIGS$IFS}${dir%/}/$desktop-xdg-terminals.list
		done
		CONFIGS=${CONFIGS:+$CONFIGS$IFS}${dir%/}/xdg-terminals.list
	done
	for dir in ${XDG_DATA_DIRS:-/usr/local/share:/usr/share}; do
		for desktop in $LOWERCASE_XDG_CURRENT_DESKTOP; do
			CONFIGS=${CONFIGS:+$CONFIGS$IFS}${dir%/}/xdg-terminal-exec/$desktop-xdg-terminals.list
		done
		CONFIGS=${CONFIGS:+$CONFIGS$IFS}${dir%/}/xdg-terminal-exec/xdg-terminals.list
	done
	for dir in ${XDG_DATA_HOME:-$HOME/.local/share}$IFS${XDG_DATA_DIRS:-/usr/local/share:/usr/share}; do
		APPLICATIONS_DIRS=${dir%/}/applications/${APPLICATIONS_DIRS:+$IFS$APPLICATIONS_DIRS}
	done
	XDG_CACHE_HOME=${XDG_CACHE_HOME:-"$HOME/.cache"}
	CACHE_FILE="$XDG_CACHE_HOME/xdg-terminal-exec"
	debug "paths:" "  CONFIGS=$CONFIGS" "  APPLICATIONS_DIRS=$APPLICATIONS_DIRS"
}
alias make_paths='IFS= make_paths'
gen_hash() {
	read -r hash _drop <<-EOH
		$(
			hash_paths="$CONFIGS:$APPLICATIONS_DIRS"
			{
				echo 4
				echo "${XDG_CURRENT_DESKTOP-}"
				IFS=':'
				debug ">     hashing '${XDG_CURRENT_DESKTOP-}' and listing of:" $hash_paths "^     end of hash listing"
				LANG=C ls -LRl $hash_paths 2>/dev/null
			} | md5sum 2>/dev/null
		)
	EOH
	case "$hash" in
	[0-9a-f]??????????????????????????????[0-9a-f])
		debug "got fresh hash '$hash'"
		echo "$hash"
		return 0
		;;
	*)
		debug "failed to get fresh hash, got '$hash'"
		return 1
		;;
	esac
}
read_cache() {
	if [ -f "$CACHE_FILE" ]; then
		line_num=0
		line_limit=50
		cached_exec_usep=
		finished=0
		while IFS='' read -r line; do
			line_num=$((line_num + 1))
			case "$line_num" in
			1) cached_hash=$line ;;
			2) cached_cmd=$line ;;
			3) cached_entry_path=$line ;;
			4) cached_entry_id=$line ;;
			5) cached_entry_action=$line ;;
			6) cached_execarg=$line ;;
			7) cached_appidarg=$line ;;
			8) cached_titlearg=$line ;;
			9) cached_dirarg=$line ;;
			10) cached_holdarg=$line ;;
			"$line_limit")
				debug "reached cache line limit ($line_limit)"
				return 1
				;;
			*)
				cached_exec_usep=$cached_exec_usep${cached_exec_usep:+$N}$line
				case "$line" in
				*"${RSEP}END_OF_EXEC_USEP")
					cached_exec_usep=${cached_exec_usep%"${RSEP}END_OF_EXEC_USEP"}
					finished=1
					break
					;;
				esac
				;;
			esac
		done <"$CACHE_FILE"
		if [ "$finished" = "1" ]; then
			debug "got cache:" \
				"hash=$cached_hash" \
				"cmd=$cached_cmd" \
				"entry_path=$cached_entry_path" \
				"entry_id=$cached_entry_id" \
				"entry_action=$cached_entry_action" \
				"execarg=$cached_execarg" \
				"appidarg=$cached_appidarg" \
				"titlearg=$cached_titlearg" \
				"dirarg=$cached_dirarg" \
				"holdarg=$cached_holdarg" \
				"exec_usep=$cached_exec_usep"
			HASH=$(gen_hash) || return 1
			if [ "$HASH" = "$cached_hash" ] && command -v "$cached_cmd" >/dev/null; then
				debug "cache is actual"
				EXEC_USEP=$cached_exec_usep
				ENTRY_PATH=$cached_entry_path
				ENTRY_ID=$cached_entry_id
				ENTRY_ACTION=$cached_entry_action
				EXECARG=$cached_execarg
				APPIDARG=$cached_appidarg
				TITLEARG=$cached_titlearg
				DIRARG=$cached_dirarg
				HOLDARG=$cached_holdarg
				return 0
			else
				debug "cache is out-of-date"
				return 1
			fi
		else
			debug "invalid cache data"
			return 1
		fi
	else
		debug "no cache data"
		return 1
	fi
}
save_cache() {
	if check_bool "$CACHE_ENABLED"; then
		[ ! -d "$XDG_CACHE_HOME" ] && mkdir -p "$XDG_CACHE_HOME"
		if [ -z "${HASH-}" ]; then
			HASH=$(gen_hash) || {
				error "could not hash listing of files, removing '$CACHE_FILE'"
				rm -f "$CACHE_FILE"
				return 0
			}
		fi
		case "$HASH$1$EXECARG$APPIDARG$TITLEARG$DIRARG$HOLDARG" in
		"$N")
			error "One or more of terminal's arguments contains a newline, removing '$CACHE_FILE'"
			rm -f "$CACHE_FILE"
			return 0
			;;
		esac
		UM=$(umask)
		umask 0077
		printf '%s\n' \
			"$HASH" \
			"$1" \
			"$ENTRY_PATH" \
			"$ENTRY_ID" \
			"$ENTRY_ACTION" \
			"$EXECARG" \
			"$APPIDARG" \
			"$TITLEARG" \
			"$DIRARG" \
			"$HOLDARG" \
			"$EXEC_USEP${RSEP}END_OF_EXEC_USEP" >"$CACHE_FILE"
		umask "$UM"
		debug ">     saved cache:" "$HASH" "$EXEC_USEP" "$EXECARG" "$1" "^     end of saved cache"
	else
		debug "cache is disabled, removing '$CACHE_FILE'"
		rm -f "$CACHE_FILE"
		return 0
	fi
}
list_contains() {
	delimiter=${3:-$N}
	case "$delimiter$1$delimiter" in
	*"$delimiter$2$delimiter"*) return 0 ;;
	*) return 1 ;;
	esac
}
read_config_paths() {
	IFS=':'
	for config_path in $CONFIGS; do
		debug "reading config '$config_path'"
		[ -f "$config_path" ] || continue
		while IFS="$OIFS" read -r line; do
			case $line in
			/enable_cache)
				debug "found '$line' directive${CACHE_CONFIGURED:+ (ignored)}"
				[ -z "$CACHE_CONFIGURED" ] || continue
				CACHE_ENABLED=true
				CACHE_CONFIGURED=1
				;;
			/disable_cache)
				debug "found '$line' directive${CACHE_CONFIGURED:+ (ignored)}"
				[ -z "$CACHE_CONFIGURED" ] || continue
				CACHE_ENABLED=false
				CACHE_CONFIGURED=1
				;;
			/execarg_compat)
				debug "found '$line' directive${EXECARG_COMPAT_CONFIGURED:+ (ignored)}"
				[ -z "$EXECARG_COMPAT_CONFIGURED" ] || continue
				EXECARG_COMPAT=true
				EXECARG_COMPAT_CONFIGURED=1
				;;
			/execarg_strict)
				debug "found '$line' directive${EXECARG_COMPAT_CONFIGURED:+ (ignored)}"
				[ -z "$EXECARG_COMPAT_CONFIGURED" ] || continue
				EXECARG_COMPAT=false
				EXECARG_COMPAT_CONFIGURED=1
				;;
			/execarg_default:*:*)
				if
					! check_bool "$EXECARG_COMPAT"
				then
					debug "ignored directive '$line' (strict mode)"
					continue
				fi
				IFS=':' read -r _directive entry_id execarg_default <<-EOF
					$line
				EOF
				if validate_entry_id "$entry_id"; then
					debug "added TerminalArgExec default '$execarg_default' for '$entry_id'"
					EXECARG_DEFAULTS=$EXECARG_DEFAULTS${EXECARG_DEFAULTS:+$N}$entry_id:$execarg_default
				fi
				;;
			[a-zA-Z0-9_]* | [+-][a-zA-Z0-9_]*)
				case "$line" in
				[+-]*)
					_line=${line#[+-]}
					exclusion=${line%"$_line"}
					line=$_line
					;;
				*) exclusion='' ;;
				esac
				IFS=':' read -r entry_id action_id <<-EOL
					$line
				EOL
				if validate_entry_id "$entry_id" && validate_action_id "$action_id"; then
					case "$exclusion" in
					'')
						ENTRY_IDS=${ENTRY_IDS:+$ENTRY_IDS$N}$line
						debug "added entry ID with action ID '$line'"
						;;
					'+')
						if
							list_contains "$EXCLUDED_ENTRY_IDS" "$entry_id"
						then
							debug "entry '$entry_id' was already excluded from fallback"
						elif list_contains "$INCLUDED_ENTRY_IDS" "$entry_id"; then
							debug "entry '$entry_id' fallback exclusion was already prevented"
						else
							debug "preventing fallback exclusion for entry '$entry_id'"
							INCLUDED_ENTRY_IDS=${INCLUDED_ENTRY_IDS:+$INCLUDED_ENTRY_IDS$N}$entry_id
						fi
						;;
					'-') if
						list_contains "$INCLUDED_ENTRY_IDS" "$entry_id"
					then
						debug "entry '$entry_id' fallback exclusion was already prevented"
					elif list_contains "$EXCLUDED_ENTRY_IDS" "$entry_id"; then
						debug "entry '$entry_id' was already excluded from fallback"
					else
						debug "excluding entry '$entry_id' from fallback"
						EXCLUDED_ENTRY_IDS=${EXCLUDED_ENTRY_IDS:+$EXCLUDED_ENTRY_IDS$N}$entry_id
					fi ;;
					esac
				else
					error "Discarded possibly misspelled entry '$line'"
				fi
				;;
			esac
		done <"$config_path"
	done
}
alias read_config_paths='IFS= read_config_paths'
replace() {
	r_remainder=$1
	REPLACED_STR=
	while [ -n "$r_remainder" ]; do
		r_left=${r_remainder%%"$2"*}
		REPLACED_STR=$REPLACED_STR$r_left
		if [ "$r_left" = "$r_remainder" ]; then
			break
		fi
		REPLACED_STR=$REPLACED_STR$3
		r_remainder=${r_remainder#*"$2"}
	done
}
de_expand_str() {
	debug "expander received: $1"
	EXPANDED_STR=
	exp_remainder=$1
	while [ -n "$exp_remainder" ]; do
		exp_left=${exp_remainder%%\\*}
		EXPANDED_STR=$EXPANDED_STR$exp_left
		debug "expander appended: $exp_left"
		if [ "$exp_left" = "$exp_remainder" ]; then
			debug "expander ended: $EXPANDED_STR"
			break
		fi
		exp_remainder=${exp_remainder#"$exp_left"\\}
		case "$exp_remainder" in
		s*)
			EXPANDED_STR=$EXPANDED_STR' '
			exp_remainder=${exp_remainder#?}
			debug "expander substituted space"
			;;
		n*)
			EXPANDED_STR=$EXPANDED_STR$N
			exp_remainder=${exp_remainder#?}
			debug "expander substituted newline"
			;;
		t*)
			EXPANDED_STR=$EXPANDED_STR'	'
			exp_remainder=${exp_remainder#?}
			debug "expander substituted tab"
			;;
		r*)
			EXPANDED_STR=$EXPANDED_STR$(printf '%b' '\r')
			exp_remainder=${exp_remainder#?}
			debug "expander substituted caret return"
			;;
		\\*)
			EXPANDED_STR=$EXPANDED_STR\\
			exp_remainder=${exp_remainder#?}
			debug "expander substituted backslash"
			;;
		esac
	done
}
de_tokenize_exec() {
	debug "tokenizer received: $1"
	EXEC_USEP=
	tok_remainder=$1
	tok_quoted=0
	tok_in_space=0
	while [ -n "$tok_remainder" ]; do
		tok_left=${tok_remainder%%[[:space:]\"\`\$\\\'\>\<\~\|\&\;\*\?\#\(\)]*}
		EXEC_USEP=$EXEC_USEP$tok_left
		debug "tokenizer appended: >$tok_left<"
		case "$tok_remainder" in
		"$tok_left")
			debug "tokenizer is out of special chars"
			break
			;;
		esac
		tok_remainder=${tok_remainder#"$tok_left"}
		cut=${tok_remainder#?}
		tok_char=${tok_remainder%"$cut"}
		unset cut
		tok_remainder=${tok_remainder#"$tok_char"}
		case "$tok_in_space$tok_left$tok_char" in
		1[[:space:]])
			debug "tokenizer still in space :) skipping space character"
			continue
			;;
		1*)
			debug "tokenizer no longer in space :("
			tok_in_space=0
			;;
		esac
		case "$tok_quoted$tok_char" in
		'1"')
			tok_quoted=0
			debug "tokenizer closed double quotes"
			continue
			;;
		'0"')
			tok_quoted=1
			debug "tokenizer opened double quotes"
			continue
			;;
		0[\`\$\\\'\>\<\~\|\&\;\*\?\#\(\)])
			debug "$entry_id: Encountered unquoted character: '$tok_char'"
			return 1
			;;
		1[\`\$])
			debug "$entry_id: Encountered unescaped quoted character: '$tok_char'"
			return 1
			;;
		1\\)
			case "$tok_remainder" in
			'')
				debug "$entry_id: Dangling backslash encountered!"
				return 1
				;;
			*)
				cut=${tok_remainder#?}
				tok_char=${tok_remainder%"$cut"}
				tok_remainder=$cut
				unset cut
				EXEC_USEP=$EXEC_USEP$tok_char
				debug "tokenizer appended escaped: >$tok_char<"
				;;
			esac
			;;
		0[[:space:]])
			case "$tok_remainder" in
			*[![:space:]]*)
				EXEC_USEP=$EXEC_USEP$USEP
				tok_in_space=1
				debug "tokenizer entered spaaaaaace!!!! separator appended"
				;;
			*)
				debug "tokenizer entered outer spaaaaaace!!!! separator skipped, this is the end"
				break
				;;
			esac
			;;
		1[[:space:]\'\>\<\~\|\&\;\*\?\#\(\)])
			EXEC_USEP=$EXEC_USEP$tok_char
			debug "tokenizer appended quoted char: >$tok_char<"
			;;
		*)
			debug "$entry_id: parsing error at char '$tok_char', (quoted: $tok_quoted)"
			return 1
			;;
		esac
	done
	case "$tok_quoted" in
	1)
		debug "$entry_id: Double quote was not closed!"
		return 1
		;;
	esac
	debug "tokenizer ended:" "$(
		IFS=$USEP
		printf '  >%s<\n' $EXEC_USEP
	)"
}
de_strip_fields() {
	exec_usep=''
	fu_found=false
	IFS=$USEP
	for arg in $EXEC_USEP; do
		case "$arg" in
		*[!%]'%'[dDnNvm]* | '%'[dDnNvm]*) debug "injector removed deprecated '$arg'" ;;
		*[!%]'%'[fFuU]* | '%'[fFuU]*)
			if
				[ "$fu_found" = "true" ]
			then
				debug "$entry_id: Encountered more than one %[fFuU] field!"
				return 1
			fi
			fu_found=true
			debug "injector removed '$arg'"
			continue
			;;
		*[!%]'%i'* | '%i'* | *[!%]'%c'* | '%c'*)
			debug "injector removed '$arg'"
			continue
			;;
		*[!%]%%* | %%*)
			replace "$arg" "%%" "%"
			rarg=$REPLACED_STR
			debug "injector replacing '%%': '$arg' -> '$rarg'"
			exec_usep=$exec_usep${exec_usep:+$USEP}$rarg
			;;
		*%?* | *[!%]%)
			debug "$entry_id: unknown % field in argument '$arg'"
			return 1
			;;
		*)
			debug "injector keeped: '$arg'"
			exec_usep=$exec_usep${exec_usep:+$USEP}$arg
			;;
		esac
	done
	EXEC_USEP=$exec_usep
	IFS=$OIFS
}
alias de_strip_fields='IFS= de_strip_fields'
reset_keys() {
	IS_TERMINAL=''
	EXEC_USEP=''
	EXECARG='-e'
	EXECARG_DEFINED=false
	APPIDARG=''
	TITLEARG=''
	DIRARG=''
	HOLDARG=''
}
find_entry_paths() {
	debug "registering entries"
	IFS=':'
	for directory in $APPLICATIONS_DIRS; do
		set -- "$@" "$directory".
	done
	set -- "$@" -type f
	or_arg=''
	for directory in $APPLICATIONS_DIRS; do
		set -- "$@" $or_arg '(' -path "$directory"'./[a-zA-Z0-9_]*.desktop' ! -path "$directory"'./*[^a-zA-Z0-9_./-]*' ')'
		or_arg='-o'
	done
	IFS=$N
	while read -r entry_path && read -r entry_id; do
		if list_contains "$EXCLUDED_ENTRY_IDS" "$entry_id"; then
			debug "entry '$entry_id' was excluded from fallback"
			continue
		fi
		alias "$entry_id"="entry_path='$entry_path'"
		debug "registered '$entry_path' as entry '$entry_id'"
		FALLBACK_ENTRY_IDS=$entry_id${FALLBACK_ENTRY_IDS:+$N$FALLBACK_ENTRY_IDS}
		debug "added fallback ID '$entry_id'"
	done <<-EOE
		$(find -L "$@" 2>/dev/null | awk '{ print; sub(".*/[.]/", ""); gsub("/", "-"); print }')
	EOE
}
alias find_entry_paths='IFS= find_entry_paths'
check_entry_key() {
	key="$1"
	value="$2"
	action="$3"
	read_exec="$4"
	de_checks="$5"
	case $key in
	'Categories'*=*)
		debug "checking for 'TerminalEmulator' in Categories '$value'"
		IFS=';'
		for category in $value; do
			[ "$category" = "TerminalEmulator" ] && {
				IS_TERMINAL=true
				return 0
			}
		done
		return 1
		;;
	'Actions'*=*)
		[ -z "$action" ] && return 0
		debug "checking for '$action' in Actions '$value'"
		IFS=';'
		for check_action in $value; do
			if [ "$check_action" = "$action" ]; then
				action_listed=true
				return 0
			fi
		done
		return 1
		;;
	'OnlyShowIn'*=*)
		case "$de_checks" in
		true) debug "checking for intersecion between '${XDG_CURRENT_DESKTOP-}' and OnlyShowIn '$value'" ;;
		false)
			debug "skipping OnlyShowIn check"
			return 0
			;;
		esac
		IFS=';'
		for target in $value; do
			IFS=':'
			for desktop in ${XDG_CURRENT_DESKTOP-}; do
				[ "$desktop" = "$target" ] && return 0
			done
		done
		return 1
		;;
	'NotShowIn'*=*)
		case "$de_checks" in
		true) debug "checking for intersecion between '${XDG_CURRENT_DESKTOP-}' and NotShowIn '$value'" ;;
		false)
			debug "skipping NotShowIn check"
			return 0
			;;
		esac
		IFS=';'
		for target in $value; do
			IFS=':'
			for desktop in ${XDG_CURRENT_DESKTOP-}; do
				debug "checking NotShowIn match '$desktop'='$target'"
				[ "$desktop" = "$target" ] && return 1
			done
		done
		return 0
		;;
	'X-TerminalArgExec'*=* | 'TerminalArgExec'*=*)
		de_expand_str "$value"
		EXECARG=$EXPANDED_STR
		EXECARG_DEFINED=true
		debug "read TerminalArgExec '$EXECARG'"
		;;
	'X-ExecArg'*=* | 'ExecArg'*=*)
		case "$EXECARG_COMPAT" in
		false) return 0 ;;
		esac
		de_expand_str "$value"
		EXECARG=$EXPANDED_STR
		EXECARG_DEFINED=true
		debug "read TerminalArgExec '$EXECARG'"
		;;
	'X-TerminalArgAppId'*=* | 'TerminalArgAppId'*=*)
		de_expand_str "$value"
		APPIDARG=$EXPANDED_STR
		debug "read TerminalArgAppId '$APPIDARG'"
		;;
	'X-TerminalArgTitle'*=* | 'TerminalArgTitle'*=*)
		de_expand_str "$value"
		TITLEARG=$EXPANDED_STR
		debug "read TerminalArgTitle '$TITLEARG'"
		;;
	'X-TerminalArgDir'*=* | 'TerminalArgDir'*=*)
		de_expand_str "$value"
		DIRARG=$EXPANDED_STR
		debug "read TerminalArgDir '$DIRARG'"
		;;
	'X-TerminalArgHold'*=* | 'TerminalArgHold'*=*)
		de_expand_str "$value"
		HOLDARG=$EXPANDED_STR
		debug "read TerminalArgHold '$HOLDARG'"
		;;
	'TryExec'*=*)
		de_expand_str "$value"
		debug "checking TryExec executable '$EXPANDED_STR'"
		command -v "$(printf '%b' "$EXPANDED_STR")" >/dev/null || return 1
		;;
	'Hidden'*=*)
		debug "checking boolean Hidden '$value'"
		case "$value" in
		true)
			debug "ignored Hidden entry"
			return 1
			;;
		esac
		;;
	'Exec'*=*)
		case "$read_exec" in
		false)
			debug "ignored Exec from wrong section"
			return 0
			;;
		esac
		debug "read Exec '$value'"
		de_expand_str "$value"
		de_tokenize_exec "$EXPANDED_STR"
		de_strip_fields
		EXEC0=${EXEC_USEP%%"$USEP"*}
		debug "checking Exec[0] executable '$EXEC0'"
		command -v "$EXEC0" >/dev/null || return 1
		;;
	esac
}
alias check_entry_key='IFS= check_entry_key'
read_entry_path() {
	entry_path="$1"
	entry_action="$2"
	de_checks="$3"
	read_exec=false
	action_listed=false
	debug "reading desktop entry '$entry_path'${entry_action:+ action '}$entry_action${entry_action:+'}"
	while IFS="$OIFS" read -r line; do
		case $line in
		'[Desktop Entry]'*) [ -z "$entry_action" ] && read_exec=true ;;
		[a-zA-Z0-9-]*)
			value=${line#*=}
			value=${value#"${value%%[! ]*}"}
			check_entry_key "$line" "$value" "$entry_action" "$read_exec" "$de_checks" && continue
			reset_keys
			debug "entry discarded"
			return 1
			;;
		"[Desktop Action $entry_action]"*)
			if
				[ "$action_listed" = "true" ]
			then
				read_exec=true
			else
				debug "action '$entry_action' was not listed in Actions"
				return 1
			fi
			;;
		'['*) [ "$read_exec" = "true" ] && break ;;
		esac
	done <"$entry_path"
}
validate_entry_id() {
	case "$1" in
	*[!a-zA-Z0-9_.-]* | *[!a-zA-Z0-9_.-] | [!a-zA-Z0-9_.-]* | [!a-zA-Z0-9_.-] | '' | .desktop)
		debug "string not valid as Entry ID: '$1'"
		return 1
		;;
	*.desktop) return 0 ;;
	*)
		debug "string not valid as Entry ID '$1'"
		return 1
		;;
	esac
}
validate_action_id() {
	case "$1" in
	'') return 0 ;;
	*[!a-zA-Z0-9-]* | *[!a-zA-Z0-9-] | [!a-zA-Z0-9-]* | [!a-zA-Z0-9-])
		debug "string not valid as Action ID: '$1'"
		return 1
		;;
	*) return 0 ;;
	esac
}
find_entry() {
	de_checks=false
	IFS="$N"
	for entry_id in $ENTRY_IDS$N//fallback_start//$N$FALLBACK_ENTRY_IDS; do
		case "$entry_id" in
		*:*)
			entry_action=${entry_id#*:}
			entry_id=${entry_id%:*}
			;;
		'') continue ;;
		'//fallback_start//')
			de_checks=true
			continue
			;;
		*) entry_action='' ;;
		esac
		debug "matching path for entry ID '$entry_id'"
		alias "$entry_id" >/dev/null 2>&1 || continue
		eval "$entry_id"
		unalias "$entry_id"
		read_entry_path "$entry_path" "$entry_action" "$de_checks" || continue
		[ -z "$EXEC_USEP" ] && continue
		[ -z "$IS_TERMINAL" ] && continue
		if [ "$EXECARG_DEFINED" != "true" ]; then
			if check_bool "$EXECARG_COMPAT"; then
				EXECARG=$(get_default_execarg "$entry_id")
			else
				continue
			fi
		fi
		ENTRY_PATH=$entry_path
		ENTRY_ID=$entry_id
		ENTRY_ACTION=$entry_action
		return 0
	done
	IFS=':' error "No valid terminal entry was found in:" $APPLICATIONS_DIRS
	return 1
}
alias find_entry='IFS= find_entry'
get_default_execarg() {
	check_entry=$1
	while IFS=':' read -r entry_id execarg_default; do
		case "$entry_id" in
		"$check_entry")
			printf '%s' "$execarg_default"
			debug "custom default TerminalArgExec '$execarg_default' for '$check_entry'"
			return 0
			;;
		esac
	done <<-EOF
		$EXECARG_DEFAULTS
	EOF
	printf '%s' '-e'
	debug "using default TerminalArgExec '-e' for '$check_entry'"
}
args=";;$(printf '%s;;' "$@")"
case "${args%%';;--;;'*};;" in
*';;-h;;'* | *';;--help;;'*)
	help
	exit 0
	;;
esac
LOWERCASE_XDG_CURRENT_DESKTOP=$(printf '%s' "${XDG_CURRENT_DESKTOP-}" | tr '[:upper:]' '[:lower:]')
EXECARG_COMPAT=${XTE_EXECARG_COMPAT-true}
EXECARG_COMPAT_CONFIGURED=${XTE_EXECARG_COMPAT-}
EXEC_USEP=''
EXPANDED_STR=''
ENTRY_PATH=''
ENTRY_ID=''
ENTRY_ACTION=''
APPLICATIONS_DIRS=''
EXECARG_DEFAULTS=''
reset_keys
make_paths
CACHE_ENABLED=${XTE_CACHE_ENABLED-true}
CACHE_CONFIGURED=${XTE_CACHE_ENABLED-}
HASH=''
if check_bool "$CACHE_ENABLED" && read_cache; then
	CACHE_USED=true
else
	CACHE_USED=false
	ENTRY_IDS=''
	FALLBACK_ENTRY_IDS=''
	EXCLUDED_ENTRY_IDS=''
	INCLUDED_ENTRY_IDS=''
	read_config_paths
	find_entry_paths
	IFS="$N" debug ">     final entry ID list:" $ENTRY_IDS "^     end of final entry ID list"
	IFS="$N" debug ">     final fallback entry ID list:" $FALLBACK_ENTRY_IDS "^     end of final fallback entry ID list"
	find_entry || exit 1
fi
debug ">     original args:" "$@" "^     end of original args" "EXEC_USEP=$EXEC_USEP" "EXECARG=$EXECARG"
debug "option processing"
APPIDVAL=''
TITLEVAL=''
DIRVAL=''
HOLD=false
TEST_MODE=false
PRINT_DATA=
PRINT_DELIMITER='\n'
PRINT_CMD_DELIMITER='\n'
while [ "$#" -gt "0" ]; do
	case "$1" in
	--)
		debug "found explicit end of options $1"
		shift
		break
		;;
	-e | "$EXECARG")
		debug "found exec arg $1"
		shift
		break
		;;
	--app-id=*)
		debug "found option $1"
		IFS='=' read -r _opt APPIDVAL <<-EOF
			$1
		EOF
		debug "set app-id option to $APPIDVAL"
		shift
		;;
	--title=*)
		debug "found option $1"
		IFS='=' read -r _opt TITLEVAL <<-EOF
			$1
		EOF
		debug "set title option to $TITLEVAL"
		shift
		;;
	--dir=*)
		debug "found option $1"
		IFS='=' read -r _opt DIRVAL <<-EOF
			$1
		EOF
		debug "set dir option to $DIRVAL"
		shift
		;;
	--hold)
		debug "found option $1"
		HOLD=true
		debug "set HOLD=true"
		shift
		;;
	--test)
		debug "found option $1"
		TEST_MODE=true
		debug "set TEST_MODE=true"
		shift
		;;
	--print-path)
		debug "found option $1"
		PRINT_DATA="$PRINT_DATA path"
		debug "set PRINT_DATA='$PRINT_DATA'"
		shift
		;;
	--print-id)
		debug "found option $1"
		PRINT_DATA="$PRINT_DATA id"
		debug "set PRINT_DATA=$PRINT_DATA"
		shift
		;;
	--print-content)
		debug "found option $1"
		PRINT_DATA="$PRINT_DATA content"
		debug "set PRINT_DATA=$PRINT_DATA"
		shift
		;;
	--print-cmd)
		debug "found option $1"
		PRINT_DATA="$PRINT_DATA cmd"
		debug "set PRINT_DATA=$PRINT_DATA"
		shift
		;;
	--print-cmd=*)
		debug "found option $1"
		PRINT_DATA="$PRINT_DATA cmd"
		IFS='=' read -r _arg PRINT_CMD_DELIMITER <<-EOF
			$1
		EOF
		debug "set PRINT_DATA=$PRINT_DATA" "set PRINT_CMD_DELIMITER=$PRINT_CMD_DELIMITER"
		shift
		;;
	--print-delimiter=*)
		debug "found option $1"
		IFS='=' read -r _arg PRINT_DELIMITER <<-EOF
			$1
		EOF
		debug "set PRINT_DELIMITER=$PRINT_DELIMITER"
		shift
		;;
	[!-]*)
		debug "found non-option $1"
		break
		;;
	-*)
		debug "discarding unknown option $1"
		shift
		;;
	esac
done
debug "end of option processing, prependig options"
PRINT_FIRST=true
case " $PRINT_DATA " in
*' id '*)
	debug "acting on --print-id"
	printf '%s' "$ENTRY_ID${ENTRY_ACTION:+:}$ENTRY_ACTION"
	PRINT_FIRST=false
	;;
esac
case " $PRINT_DATA " in
*' path '*)
	debug "acting on --print-path"
	case "$ENTRY_PATH" in
	*'/./'*) ENTRY_PATH=${ENTRY_PATH%%/./*}/${ENTRY_PATH##*/./} ;;
	esac
	case "$PRINT_FIRST" in
	false) printf '%b' "$PRINT_DELIMITER" ;;
	esac
	printf '%s' "$ENTRY_PATH${ENTRY_ACTION:+:}$ENTRY_ACTION"
	PRINT_FIRST=false
	;;
esac
case " $PRINT_DATA " in
*' content '*)
	debug "acting on --print-content"
	case "$PRINT_FIRST" in
	false) printf '%b' "$PRINT_DELIMITER" ;;
	esac
	shcat <"$ENTRY_PATH"
	PRINT_FIRST=false
	;;
esac
case " $PRINT_DATA " in
'  ' | *' cmd '*)
	true
	;;
*' content '*)
	exit 0
	;;
*)
	case "$PRINT_DELIMITER" in
	'\n') printf '%b' '\n' ;;
	esac
	exit 0
	;;
esac
if [ "$#" -gt 0 ] && [ -n "$EXECARG" ]; then
	set -- "$EXECARG" "$@"
	debug "prepended $1"
fi
if [ -n "$HOLDARG" ] && check_bool "$HOLD"; then
	set -- "$HOLDARG" "$@"
	debug "prepended $1"
elif [ -z "$HOLDARG" ] && check_bool "$HOLD"; then
	debug "terminal entry has no TerminalArgHold="
fi
if [ -n "$DIRARG" ] && [ -n "$DIRVAL" ]; then
	case "$DIRARG" in
	*=)
		set -- "$DIRARG$DIRVAL" "$@"
		debug "prepended $1"
		;;
	*)
		set -- "$DIRARG" "$DIRVAL" "$@"
		debug "prepended $1 $2"
		;;
	esac
elif [ -z "$DIRARG" ] && [ -n "$DIRVAL" ]; then
	debug "terminal entry has no TerminalArgDir="
fi
if [ -n "$TITLEARG" ] && [ -n "$TITLEVAL" ]; then
	case "$TITLEARG" in
	*=)
		set -- "$TITLEARG$TITLEVAL" "$@"
		debug "prepended $1"
		;;
	*)
		set -- "$TITLEARG" "$TITLEVAL" "$@"
		debug "prepended $1 $2"
		;;
	esac
elif [ -z "$TITLEARG" ] && [ -n "$TITLEVAL" ]; then
	debug "terminal entry has no TerminalArgTitle="
fi
if [ -n "$APPIDARG" ] && [ -n "$APPIDVAL" ]; then
	case "$APPIDARG" in
	*=)
		set -- "$APPIDARG$APPIDVAL" "$@"
		debug "prepended $1"
		;;
	*)
		set -- "$APPIDARG" "$APPIDVAL" "$@"
		debug "prepended $1 $2"
		;;
	esac
elif [ -z "$APPIDARG" ] && [ -n "$APPIDVAL" ]; then
	debug "terminal entry has no TerminalArgAppId="
fi
debug "end of option prepending"
IFS=$USEP
set -- $EXEC_USEP "$@"
IFS=$OIFS
debug ">     final args:" "$@" "^     end of final args"
if [ "$CACHE_USED" = "false" ]; then
	save_cache "$1" &
fi
case "$TEST_MODE" in
true)
	printf '%s\n' 'Command and arguments:'
	printf '  >%s<\n' "$@"
	exit 0
	;;
esac
case " $PRINT_DATA " in
*' cmd '*)
	debug "acting on --print-cmd"
	case "$PRINT_FIRST" in
	false) printf '%b' "$PRINT_DELIMITER" ;;
	esac
	first=true
	for arg in "$@"; do
		case "$first" in
		true) first=false ;;
		false) printf '%b' "${PRINT_CMD_DELIMITER:-\n}" ;;
		esac
		printf '%s' "$arg"
	done
	if [ "$PRINT_CMD_DELIMITER" = '\n' ] || { [ "$PRINT_FIRST" = "false" ] && [ "$PRINT_DELIMITER" = '\n' ]; }; then
		printf '%b' '\n'
	fi
	exit 0
	;;
esac
if [ -z "$DIRARG" ] && [ -n "$DIRVAL" ]; then
	debug "no X-TerminalArgDir in entry, changing dir to '$DIRVAL'"
	cd "$DIRVAL"
fi
exec "$@"
